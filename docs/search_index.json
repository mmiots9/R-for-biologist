[["index.html", "Learn R for biologist, with no fear About", " Learn R for biologist, with no fear Matteo Miotto 2022-12-05 About Ciao Fede, here we are. You really don’t know how happy I am for both of us: I’ll learn how to “teach”, while you’ll learn a coding language that will revolutionize your life, I’m sure of it hahaha We’ll see how to speed up analyses, how to automate them, how to untie ourselves from that cancer that is Excel, how to make beautiful graphs and how to gain time to do other things. First, you need to start with the installation and some basic concepts. Let’s start this beautiful journey! "],["installation.html", "1 Installation", " 1 Installation First of all, we need to install R to be able to use it. To do so, go to this link and follow the instruction for the installation. … Done?! Great, now you can start using R on your pc, directly from your terminal: but since it is an inconvenient and ancient way, let’s take advantage of the potential and functions of RStudio to be true professionals. Go here and download this amazing software. … Done?! Perfect, let’s open it. "],["first-step-in-rstudio.html", "2 First step in RStudio Console", " 2 First step in RStudio Don’t be intimidated by all these windows that you see open, we will slowly dig into them one by one. Console Let’s start from the console, that is the space where we will start writing the first commands and where their outputs are displayed. Let’s try a basic thing right away, using R as a calculator, type 2 + 2 on the console and press enter. 2+2 [1] 4 Easy right? It returns 4. Now you can start playing a bit with the various operations, you can also write long expressions and you will see how the result will be shown immediately. … Ok, but… usually we need the results of some operation to be saved, or often we want to use the same number several times without having to remember it, and this is where the concept of variable comes into play. "],["variables.html", "3 Variables Create a variable Use a variable Variable names Overwriting variables List all variables Delete variables Type of variables Exercises", " 3 Variables As mentioned, we often need some number (eg a concentration), some table (eg table of differentially expressed genes), information (eg the name of a protein) etc. to be saved in R to be able to use them later in the analysis. This is where variables come into play, and now we’ll see how to create them, how to reuse them, and what kinds of variables exist. Create a variable To create a variable we write name_of_the_variable &lt;- what_to_save (you can either use = instead of &lt;-, even if the former is usually used for declaring arguments in a function, but we’ll see it later). Now, write this to the console, click Return/send on the keyborard, and see what happens: myvar &lt;- 5 On the console nothing happens, but something appeared in the window called Environment (if yours is different, it may be that there is the “List” view setting instead of “Grid” in the blue box, you can change it to your liking). Here in details the info given for each variable: Name: name of the variable Type: type of the variable (don’t worry, we’ll see in a minute what this means) Length:: the length of the variable (how many items it contains) Size: how much memory that variable occupies Value: the value of our variable If we want to create multiple variables with the same value we can do this: var1 &lt;- var2 &lt;- var3 &lt;- 20 print(var1) [1] 20 print(var2) [1] 20 print(var3) [1] 20 Use a variable Ok, but once stored, how to we use a variable? Easy, we just need to type it in the console (or start writing the first letters of its name and press Tab to show RStudio suggestions). If, for example, we want to calculate the power of our variable we should write: myvar ** 2 [1] 25 And here is the result (to elevate to the power we can either use ** or ^). And what if we want to store this result? As before: myvar_power &lt;- myvar ** 2 print(myvar_power) [1] 25 Here we use print() function, but in R we can also just write the name of the variable to see it. Variable names As in everything, even in naming variables there are rules and guidelines. Don’t be scared, they are simple and will make your life easier, let’s see them together. Rules: Variable name CANNOT start with a character other than a letter Variable name can contain both letters and numbers (case sensitive, uppercase and lowercase matter) Variable name may contain as special characters only the dot . or the underscore _ Guidelines: Since the name of the variable must be useful, its name must suggest something: for example, the variable myvar was previously defined, whose meaning is equal to 0 (so avoid these names), while myvar_power is more indicative, as it tells us that it is raised to a power Variables are normally written in lowercase letters, except for those you want to remain constant in your analysis, which in other languages are written in uppercase (this does not make them immutable, but suggests this feature within the script) Use underscores rather than periods as special characters in variable names if you can If the variable name contains more than one word, you can separate them with an underscore (as in the example) or use the camel case (myvarPower) or the Pascal case (MyvarPower) Be consistent within the script: if you decide to use the Pascal case, always use the Pascal case in that script Overwriting variables Attention! Variables can be overwritten (unrecoverable action). To override a variable, simply assign that variable a new value: print(myvar) [1] 5 myvar &lt;- 9 print(myvar) [1] 9 Now myvar is equal to 9, and there is no way back… This feature is useful for saving space and not cluttering up too much with variables that are okay to change often, but it can be risky. So be careful when naming variables. List all variables A useful way to avoid overwriting an important variable is to list the variables. We know that in RStudio they are all present in the Environment window, but what if we weren’t in RStudio but elsewhere (for example in the terminal)? The answer is simple, let’s use the ls() function ls() [1] &quot;aa_num&quot; &quot;age_inf_threshold&quot; &quot;age_sup_threshold&quot; &quot;all_string&quot; [5] &quot;areas&quot; &quot;ch1&quot; &quot;ch2&quot; &quot;ch3&quot; [9] &quot;ch4&quot; &quot;ch5&quot; &quot;ch6&quot; &quot;common&quot; [13] &quot;common_all&quot; &quot;common_mean&quot; &quot;common1_2&quot; &quot;condition&quot; [17] &quot;expr&quot; &quot;expr_levels&quot; &quot;expr_values&quot; &quot;f_value&quot; [21] &quot;features&quot; &quot;gene&quot; &quot;gene_to_test&quot; &quot;gene1&quot; [25] &quot;gene2&quot; &quot;genes&quot; &quot;grep_1&quot; &quot;grep_2&quot; [29] &quot;grepl_1&quot; &quot;grepl_2&quot; &quot;gsub_all&quot; &quot;heights&quot; [33] &quot;idx&quot; &quot;mean_res_better&quot; &quot;mean_res_better_round&quot; &quot;mean_result_calc&quot; [37] &quot;mean_time&quot; &quot;mice1&quot; &quot;mice2&quot; &quot;mice3&quot; [41] &quot;mice4&quot; &quot;mito_genes&quot; &quot;ml_to_add&quot; &quot;mother_diabetes&quot; [45] &quot;my_info&quot; &quot;my_vector&quot; &quot;mychar_d&quot; &quot;mychar_s&quot; [49] &quot;mynumber&quot; &quot;mystring&quot; &quot;myvar&quot; &quot;myvar_power&quot; [53] &quot;n_rep&quot; &quot;n_responders&quot; &quot;nationality&quot; &quot;not_center&quot; [57] &quot;num1&quot; &quot;num2&quot; &quot;only_1&quot; &quot;only_2&quot; [61] &quot;p_responders&quot; &quot;patien1_sub&quot; &quot;patien2_sub&quot; &quot;patien3_sub&quot; [65] &quot;patient_age&quot; &quot;patient_state&quot; &quot;patient_weight&quot; &quot;patient1&quot; [69] &quot;patient2&quot; &quot;patient3&quot; &quot;pattern_to_check_1&quot; &quot;pattern_to_check_2&quot; [73] &quot;perc_mito&quot; &quot;perc_no_mito&quot; &quot;proteins&quot; &quot;proteins1&quot; [77] &quot;proteins2&quot; &quot;rep1&quot; &quot;rep2&quot; &quot;rep3&quot; [81] &quot;response&quot; &quot;sample&quot; &quot;sample0&quot; &quot;sample1&quot; [85] &quot;sample1_fr&quot; &quot;sample2&quot; &quot;sample2_fr&quot; &quot;sample3&quot; [89] &quot;sample3_fr&quot; &quot;sd_calc&quot; &quot;sd_calc_ceil&quot; &quot;sd_calc_floor&quot; [93] &quot;sd_calc_round&quot; &quot;sd_time&quot; &quot;sub_only&quot; &quot;sum_aa&quot; [97] &quot;sum_time&quot; &quot;sum_weights&quot; &quot;t_value&quot; &quot;time&quot; [101] &quot;to_extract&quot; &quot;to_print&quot; &quot;total_mito&quot; &quot;total_no_mito&quot; [105] &quot;treatment&quot; &quot;upregulated_1&quot; &quot;upregulated_2&quot; &quot;var_calc&quot; [109] &quot;var1&quot; &quot;var2&quot; &quot;var3&quot; &quot;weight_c&quot; [113] &quot;weight_n&quot; &quot;weight_sup_threshold&quot; Here are our variables. Note how I called this command with the name function: we will cover this concept later, for now you just need to know that they exist and that they can be identified immediately by the fact that after the name there is a pair of round brackets. Delete variables To delete a variable, use the rm() function and insert the variable to be deleted: # create a variable to_remove &lt;- 1213 # list all variables ls() [1] &quot;aa_num&quot; &quot;age_inf_threshold&quot; &quot;age_sup_threshold&quot; &quot;all_string&quot; [5] &quot;areas&quot; &quot;ch1&quot; &quot;ch2&quot; &quot;ch3&quot; [9] &quot;ch4&quot; &quot;ch5&quot; &quot;ch6&quot; &quot;common&quot; [13] &quot;common_all&quot; &quot;common_mean&quot; &quot;common1_2&quot; &quot;condition&quot; [17] &quot;expr&quot; &quot;expr_levels&quot; &quot;expr_values&quot; &quot;f_value&quot; [21] &quot;features&quot; &quot;gene&quot; &quot;gene_to_test&quot; &quot;gene1&quot; [25] &quot;gene2&quot; &quot;genes&quot; &quot;grep_1&quot; &quot;grep_2&quot; [29] &quot;grepl_1&quot; &quot;grepl_2&quot; &quot;gsub_all&quot; &quot;heights&quot; [33] &quot;idx&quot; &quot;mean_res_better&quot; &quot;mean_res_better_round&quot; &quot;mean_result_calc&quot; [37] &quot;mean_time&quot; &quot;mice1&quot; &quot;mice2&quot; &quot;mice3&quot; [41] &quot;mice4&quot; &quot;mito_genes&quot; &quot;ml_to_add&quot; &quot;mother_diabetes&quot; [45] &quot;my_info&quot; &quot;my_vector&quot; &quot;mychar_d&quot; &quot;mychar_s&quot; [49] &quot;mynumber&quot; &quot;mystring&quot; &quot;myvar&quot; &quot;myvar_power&quot; [53] &quot;n_rep&quot; &quot;n_responders&quot; &quot;nationality&quot; &quot;not_center&quot; [57] &quot;num1&quot; &quot;num2&quot; &quot;only_1&quot; &quot;only_2&quot; [61] &quot;p_responders&quot; &quot;patien1_sub&quot; &quot;patien2_sub&quot; &quot;patien3_sub&quot; [65] &quot;patient_age&quot; &quot;patient_state&quot; &quot;patient_weight&quot; &quot;patient1&quot; [69] &quot;patient2&quot; &quot;patient3&quot; &quot;pattern_to_check_1&quot; &quot;pattern_to_check_2&quot; [73] &quot;perc_mito&quot; &quot;perc_no_mito&quot; &quot;proteins&quot; &quot;proteins1&quot; [77] &quot;proteins2&quot; &quot;rep1&quot; &quot;rep2&quot; &quot;rep3&quot; [81] &quot;response&quot; &quot;sample&quot; &quot;sample0&quot; &quot;sample1&quot; [85] &quot;sample1_fr&quot; &quot;sample2&quot; &quot;sample2_fr&quot; &quot;sample3&quot; [89] &quot;sample3_fr&quot; &quot;sd_calc&quot; &quot;sd_calc_ceil&quot; &quot;sd_calc_floor&quot; [93] &quot;sd_calc_round&quot; &quot;sd_time&quot; &quot;sub_only&quot; &quot;sum_aa&quot; [97] &quot;sum_time&quot; &quot;sum_weights&quot; &quot;t_value&quot; &quot;time&quot; [101] &quot;to_extract&quot; &quot;to_print&quot; &quot;to_remove&quot; &quot;total_mito&quot; [105] &quot;total_no_mito&quot; &quot;treatment&quot; &quot;upregulated_1&quot; &quot;upregulated_2&quot; [109] &quot;var_calc&quot; &quot;var1&quot; &quot;var2&quot; &quot;var3&quot; [113] &quot;weight_c&quot; &quot;weight_n&quot; &quot;weight_sup_threshold&quot; # delete just-created variable rm(to_remove) # list all variables ls() [1] &quot;aa_num&quot; &quot;age_inf_threshold&quot; &quot;age_sup_threshold&quot; &quot;all_string&quot; [5] &quot;areas&quot; &quot;ch1&quot; &quot;ch2&quot; &quot;ch3&quot; [9] &quot;ch4&quot; &quot;ch5&quot; &quot;ch6&quot; &quot;common&quot; [13] &quot;common_all&quot; &quot;common_mean&quot; &quot;common1_2&quot; &quot;condition&quot; [17] &quot;expr&quot; &quot;expr_levels&quot; &quot;expr_values&quot; &quot;f_value&quot; [21] &quot;features&quot; &quot;gene&quot; &quot;gene_to_test&quot; &quot;gene1&quot; [25] &quot;gene2&quot; &quot;genes&quot; &quot;grep_1&quot; &quot;grep_2&quot; [29] &quot;grepl_1&quot; &quot;grepl_2&quot; &quot;gsub_all&quot; &quot;heights&quot; [33] &quot;idx&quot; &quot;mean_res_better&quot; &quot;mean_res_better_round&quot; &quot;mean_result_calc&quot; [37] &quot;mean_time&quot; &quot;mice1&quot; &quot;mice2&quot; &quot;mice3&quot; [41] &quot;mice4&quot; &quot;mito_genes&quot; &quot;ml_to_add&quot; &quot;mother_diabetes&quot; [45] &quot;my_info&quot; &quot;my_vector&quot; &quot;mychar_d&quot; &quot;mychar_s&quot; [49] &quot;mynumber&quot; &quot;mystring&quot; &quot;myvar&quot; &quot;myvar_power&quot; [53] &quot;n_rep&quot; &quot;n_responders&quot; &quot;nationality&quot; &quot;not_center&quot; [57] &quot;num1&quot; &quot;num2&quot; &quot;only_1&quot; &quot;only_2&quot; [61] &quot;p_responders&quot; &quot;patien1_sub&quot; &quot;patien2_sub&quot; &quot;patien3_sub&quot; [65] &quot;patient_age&quot; &quot;patient_state&quot; &quot;patient_weight&quot; &quot;patient1&quot; [69] &quot;patient2&quot; &quot;patient3&quot; &quot;pattern_to_check_1&quot; &quot;pattern_to_check_2&quot; [73] &quot;perc_mito&quot; &quot;perc_no_mito&quot; &quot;proteins&quot; &quot;proteins1&quot; [77] &quot;proteins2&quot; &quot;rep1&quot; &quot;rep2&quot; &quot;rep3&quot; [81] &quot;response&quot; &quot;sample&quot; &quot;sample0&quot; &quot;sample1&quot; [85] &quot;sample1_fr&quot; &quot;sample2&quot; &quot;sample2_fr&quot; &quot;sample3&quot; [89] &quot;sample3_fr&quot; &quot;sd_calc&quot; &quot;sd_calc_ceil&quot; &quot;sd_calc_floor&quot; [93] &quot;sd_calc_round&quot; &quot;sd_time&quot; &quot;sub_only&quot; &quot;sum_aa&quot; [97] &quot;sum_time&quot; &quot;sum_weights&quot; &quot;t_value&quot; &quot;time&quot; [101] &quot;to_extract&quot; &quot;to_print&quot; &quot;total_mito&quot; &quot;total_no_mito&quot; [105] &quot;treatment&quot; &quot;upregulated_1&quot; &quot;upregulated_2&quot; &quot;var_calc&quot; [109] &quot;var1&quot; &quot;var2&quot; &quot;var3&quot; &quot;weight_c&quot; [113] &quot;weight_n&quot; &quot;weight_sup_threshold&quot; As we see, in the second case the to_remove variable has been removed. What if I want to remove multiple variables? Let’s put multiple variable names inside the rm() function separated by commas: # create various variables to_remove &lt;- 1213 to_remove2 &lt;- 685 # list all variables ls() [1] &quot;aa_num&quot; &quot;age_inf_threshold&quot; &quot;age_sup_threshold&quot; &quot;all_string&quot; [5] &quot;areas&quot; &quot;ch1&quot; &quot;ch2&quot; &quot;ch3&quot; [9] &quot;ch4&quot; &quot;ch5&quot; &quot;ch6&quot; &quot;common&quot; [13] &quot;common_all&quot; &quot;common_mean&quot; &quot;common1_2&quot; &quot;condition&quot; [17] &quot;expr&quot; &quot;expr_levels&quot; &quot;expr_values&quot; &quot;f_value&quot; [21] &quot;features&quot; &quot;gene&quot; &quot;gene_to_test&quot; &quot;gene1&quot; [25] &quot;gene2&quot; &quot;genes&quot; &quot;grep_1&quot; &quot;grep_2&quot; [29] &quot;grepl_1&quot; &quot;grepl_2&quot; &quot;gsub_all&quot; &quot;heights&quot; [33] &quot;idx&quot; &quot;mean_res_better&quot; &quot;mean_res_better_round&quot; &quot;mean_result_calc&quot; [37] &quot;mean_time&quot; &quot;mice1&quot; &quot;mice2&quot; &quot;mice3&quot; [41] &quot;mice4&quot; &quot;mito_genes&quot; &quot;ml_to_add&quot; &quot;mother_diabetes&quot; [45] &quot;my_info&quot; &quot;my_vector&quot; &quot;mychar_d&quot; &quot;mychar_s&quot; [49] &quot;mynumber&quot; &quot;mystring&quot; &quot;myvar&quot; &quot;myvar_power&quot; [53] &quot;n_rep&quot; &quot;n_responders&quot; &quot;nationality&quot; &quot;not_center&quot; [57] &quot;num1&quot; &quot;num2&quot; &quot;only_1&quot; &quot;only_2&quot; [61] &quot;p_responders&quot; &quot;patien1_sub&quot; &quot;patien2_sub&quot; &quot;patien3_sub&quot; [65] &quot;patient_age&quot; &quot;patient_state&quot; &quot;patient_weight&quot; &quot;patient1&quot; [69] &quot;patient2&quot; &quot;patient3&quot; &quot;pattern_to_check_1&quot; &quot;pattern_to_check_2&quot; [73] &quot;perc_mito&quot; &quot;perc_no_mito&quot; &quot;proteins&quot; &quot;proteins1&quot; [77] &quot;proteins2&quot; &quot;rep1&quot; &quot;rep2&quot; &quot;rep3&quot; [81] &quot;response&quot; &quot;sample&quot; &quot;sample0&quot; &quot;sample1&quot; [85] &quot;sample1_fr&quot; &quot;sample2&quot; &quot;sample2_fr&quot; &quot;sample3&quot; [89] &quot;sample3_fr&quot; &quot;sd_calc&quot; &quot;sd_calc_ceil&quot; &quot;sd_calc_floor&quot; [93] &quot;sd_calc_round&quot; &quot;sd_time&quot; &quot;sub_only&quot; &quot;sum_aa&quot; [97] &quot;sum_time&quot; &quot;sum_weights&quot; &quot;t_value&quot; &quot;time&quot; [101] &quot;to_extract&quot; &quot;to_print&quot; &quot;to_remove&quot; &quot;to_remove2&quot; [105] &quot;total_mito&quot; &quot;total_no_mito&quot; &quot;treatment&quot; &quot;upregulated_1&quot; [109] &quot;upregulated_2&quot; &quot;var_calc&quot; &quot;var1&quot; &quot;var2&quot; [113] &quot;var3&quot; &quot;weight_c&quot; &quot;weight_n&quot; &quot;weight_sup_threshold&quot; # delete just-created variables rm(to_remove, to_remove2) # list all variables ls() [1] &quot;aa_num&quot; &quot;age_inf_threshold&quot; &quot;age_sup_threshold&quot; &quot;all_string&quot; [5] &quot;areas&quot; &quot;ch1&quot; &quot;ch2&quot; &quot;ch3&quot; [9] &quot;ch4&quot; &quot;ch5&quot; &quot;ch6&quot; &quot;common&quot; [13] &quot;common_all&quot; &quot;common_mean&quot; &quot;common1_2&quot; &quot;condition&quot; [17] &quot;expr&quot; &quot;expr_levels&quot; &quot;expr_values&quot; &quot;f_value&quot; [21] &quot;features&quot; &quot;gene&quot; &quot;gene_to_test&quot; &quot;gene1&quot; [25] &quot;gene2&quot; &quot;genes&quot; &quot;grep_1&quot; &quot;grep_2&quot; [29] &quot;grepl_1&quot; &quot;grepl_2&quot; &quot;gsub_all&quot; &quot;heights&quot; [33] &quot;idx&quot; &quot;mean_res_better&quot; &quot;mean_res_better_round&quot; &quot;mean_result_calc&quot; [37] &quot;mean_time&quot; &quot;mice1&quot; &quot;mice2&quot; &quot;mice3&quot; [41] &quot;mice4&quot; &quot;mito_genes&quot; &quot;ml_to_add&quot; &quot;mother_diabetes&quot; [45] &quot;my_info&quot; &quot;my_vector&quot; &quot;mychar_d&quot; &quot;mychar_s&quot; [49] &quot;mynumber&quot; &quot;mystring&quot; &quot;myvar&quot; &quot;myvar_power&quot; [53] &quot;n_rep&quot; &quot;n_responders&quot; &quot;nationality&quot; &quot;not_center&quot; [57] &quot;num1&quot; &quot;num2&quot; &quot;only_1&quot; &quot;only_2&quot; [61] &quot;p_responders&quot; &quot;patien1_sub&quot; &quot;patien2_sub&quot; &quot;patien3_sub&quot; [65] &quot;patient_age&quot; &quot;patient_state&quot; &quot;patient_weight&quot; &quot;patient1&quot; [69] &quot;patient2&quot; &quot;patient3&quot; &quot;pattern_to_check_1&quot; &quot;pattern_to_check_2&quot; [73] &quot;perc_mito&quot; &quot;perc_no_mito&quot; &quot;proteins&quot; &quot;proteins1&quot; [77] &quot;proteins2&quot; &quot;rep1&quot; &quot;rep2&quot; &quot;rep3&quot; [81] &quot;response&quot; &quot;sample&quot; &quot;sample0&quot; &quot;sample1&quot; [85] &quot;sample1_fr&quot; &quot;sample2&quot; &quot;sample2_fr&quot; &quot;sample3&quot; [89] &quot;sample3_fr&quot; &quot;sd_calc&quot; &quot;sd_calc_ceil&quot; &quot;sd_calc_floor&quot; [93] &quot;sd_calc_round&quot; &quot;sd_time&quot; &quot;sub_only&quot; &quot;sum_aa&quot; [97] &quot;sum_time&quot; &quot;sum_weights&quot; &quot;t_value&quot; &quot;time&quot; [101] &quot;to_extract&quot; &quot;to_print&quot; &quot;total_mito&quot; &quot;total_no_mito&quot; [105] &quot;treatment&quot; &quot;upregulated_1&quot; &quot;upregulated_2&quot; &quot;var_calc&quot; [109] &quot;var1&quot; &quot;var2&quot; &quot;var3&quot; &quot;weight_c&quot; [113] &quot;weight_n&quot; &quot;weight_sup_threshold&quot; The two variables have been removed. But looking closely at these codes, we see that some start with # and are not evaluated. What are they? These are the comments, i.e. messages that you will write in the scripts (and we will see later how to create them) to help you understand what you are doing. They are actual comments that you can add, and will not be “evaluated” as code as the line starts with #. Type of variables So far so linear, right? Great, it will continue to be as easy 🙃. Let’s see what are the basic types of variables that exist in R: Numeric: numbers, can be integer (whole numbers) or double (decimal numbers) Character: characters, therefore strings of letters (words, sentences, etc.) Boolean: TRUE or FALSE, are a special type of variable that R interprets in its own way, but super super super useful Factor: similar to character, but with peculiar features (and memory saving), often used for categorical variables such as male/female, heterozygous/wild-type We will see each type of variable in detail in next chapters. To find out what type a variable is we use the typeof() function: typeof(myvar) [1] &quot;double&quot; We see that myvar is a double (although it is an integer value), this is because R basically interprets every number as a double, so as to increase its precision and the possibility of operations between various numbers without having type problems. Exercises Ok, this chapter was long enough, let’s do some exercises to fix well these concepts. Exercise 3.1 Create 3 variables indicating the weights of 3 mice. Solution mice1 &lt;- 5.8 mice2 &lt;- 4.8 mice3 &lt;- 7.5 print(mice1) [1] 5.8 print(mice2) [1] 4.8 print(mice3) [1] 7.5 Exercise 3.2 Create the variable sum_weights as the sum of the weights of those 3 mice. Solution sum_weights &lt;- mice1 + mice2 + mice3 print(sum_weights) [1] 18.1 Exercise 3.3 Create 4 other variables for other 4 mice that weight 20 g. Then you realize you did a mistake and you choose to delete 3 of them and change the fourth to 7.7. Solution # create 4 variables mice4 &lt;- mice5 &lt;- mice6 &lt;- mice7 &lt;- 20 # list all variables ls() [1] &quot;aa_num&quot; &quot;age_inf_threshold&quot; &quot;age_sup_threshold&quot; &quot;all_string&quot; [5] &quot;areas&quot; &quot;ch1&quot; &quot;ch2&quot; &quot;ch3&quot; [9] &quot;ch4&quot; &quot;ch5&quot; &quot;ch6&quot; &quot;common&quot; [13] &quot;common_all&quot; &quot;common_mean&quot; &quot;common1_2&quot; &quot;condition&quot; [17] &quot;expr&quot; &quot;expr_levels&quot; &quot;expr_values&quot; &quot;f_value&quot; [21] &quot;features&quot; &quot;gene&quot; &quot;gene_to_test&quot; &quot;gene1&quot; [25] &quot;gene2&quot; &quot;genes&quot; &quot;grep_1&quot; &quot;grep_2&quot; [29] &quot;grepl_1&quot; &quot;grepl_2&quot; &quot;gsub_all&quot; &quot;heights&quot; [33] &quot;idx&quot; &quot;mean_res_better&quot; &quot;mean_res_better_round&quot; &quot;mean_result_calc&quot; [37] &quot;mean_time&quot; &quot;mice1&quot; &quot;mice2&quot; &quot;mice3&quot; [41] &quot;mice4&quot; &quot;mice5&quot; &quot;mice6&quot; &quot;mice7&quot; [45] &quot;mito_genes&quot; &quot;ml_to_add&quot; &quot;mother_diabetes&quot; &quot;my_info&quot; [49] &quot;my_vector&quot; &quot;mychar_d&quot; &quot;mychar_s&quot; &quot;mynumber&quot; [53] &quot;mystring&quot; &quot;myvar&quot; &quot;myvar_power&quot; &quot;n_rep&quot; [57] &quot;n_responders&quot; &quot;nationality&quot; &quot;not_center&quot; &quot;num1&quot; [61] &quot;num2&quot; &quot;only_1&quot; &quot;only_2&quot; &quot;p_responders&quot; [65] &quot;patien1_sub&quot; &quot;patien2_sub&quot; &quot;patien3_sub&quot; &quot;patient_age&quot; [69] &quot;patient_state&quot; &quot;patient_weight&quot; &quot;patient1&quot; &quot;patient2&quot; [73] &quot;patient3&quot; &quot;pattern_to_check_1&quot; &quot;pattern_to_check_2&quot; &quot;perc_mito&quot; [77] &quot;perc_no_mito&quot; &quot;proteins&quot; &quot;proteins1&quot; &quot;proteins2&quot; [81] &quot;rep1&quot; &quot;rep2&quot; &quot;rep3&quot; &quot;response&quot; [85] &quot;sample&quot; &quot;sample0&quot; &quot;sample1&quot; &quot;sample1_fr&quot; [89] &quot;sample2&quot; &quot;sample2_fr&quot; &quot;sample3&quot; &quot;sample3_fr&quot; [93] &quot;sd_calc&quot; &quot;sd_calc_ceil&quot; &quot;sd_calc_floor&quot; &quot;sd_calc_round&quot; [97] &quot;sd_time&quot; &quot;sub_only&quot; &quot;sum_aa&quot; &quot;sum_time&quot; [101] &quot;sum_weights&quot; &quot;t_value&quot; &quot;time&quot; &quot;to_extract&quot; [105] &quot;to_print&quot; &quot;total_mito&quot; &quot;total_no_mito&quot; &quot;treatment&quot; [109] &quot;upregulated_1&quot; &quot;upregulated_2&quot; &quot;var_calc&quot; &quot;var1&quot; [113] &quot;var2&quot; &quot;var3&quot; &quot;weight_c&quot; &quot;weight_n&quot; [117] &quot;weight_sup_threshold&quot; # delete 3 of the just-created variables rm(mice5, mice6, mice7) # list all variables ls() [1] &quot;aa_num&quot; &quot;age_inf_threshold&quot; &quot;age_sup_threshold&quot; &quot;all_string&quot; [5] &quot;areas&quot; &quot;ch1&quot; &quot;ch2&quot; &quot;ch3&quot; [9] &quot;ch4&quot; &quot;ch5&quot; &quot;ch6&quot; &quot;common&quot; [13] &quot;common_all&quot; &quot;common_mean&quot; &quot;common1_2&quot; &quot;condition&quot; [17] &quot;expr&quot; &quot;expr_levels&quot; &quot;expr_values&quot; &quot;f_value&quot; [21] &quot;features&quot; &quot;gene&quot; &quot;gene_to_test&quot; &quot;gene1&quot; [25] &quot;gene2&quot; &quot;genes&quot; &quot;grep_1&quot; &quot;grep_2&quot; [29] &quot;grepl_1&quot; &quot;grepl_2&quot; &quot;gsub_all&quot; &quot;heights&quot; [33] &quot;idx&quot; &quot;mean_res_better&quot; &quot;mean_res_better_round&quot; &quot;mean_result_calc&quot; [37] &quot;mean_time&quot; &quot;mice1&quot; &quot;mice2&quot; &quot;mice3&quot; [41] &quot;mice4&quot; &quot;mito_genes&quot; &quot;ml_to_add&quot; &quot;mother_diabetes&quot; [45] &quot;my_info&quot; &quot;my_vector&quot; &quot;mychar_d&quot; &quot;mychar_s&quot; [49] &quot;mynumber&quot; &quot;mystring&quot; &quot;myvar&quot; &quot;myvar_power&quot; [53] &quot;n_rep&quot; &quot;n_responders&quot; &quot;nationality&quot; &quot;not_center&quot; [57] &quot;num1&quot; &quot;num2&quot; &quot;only_1&quot; &quot;only_2&quot; [61] &quot;p_responders&quot; &quot;patien1_sub&quot; &quot;patien2_sub&quot; &quot;patien3_sub&quot; [65] &quot;patient_age&quot; &quot;patient_state&quot; &quot;patient_weight&quot; &quot;patient1&quot; [69] &quot;patient2&quot; &quot;patient3&quot; &quot;pattern_to_check_1&quot; &quot;pattern_to_check_2&quot; [73] &quot;perc_mito&quot; &quot;perc_no_mito&quot; &quot;proteins&quot; &quot;proteins1&quot; [77] &quot;proteins2&quot; &quot;rep1&quot; &quot;rep2&quot; &quot;rep3&quot; [81] &quot;response&quot; &quot;sample&quot; &quot;sample0&quot; &quot;sample1&quot; [85] &quot;sample1_fr&quot; &quot;sample2&quot; &quot;sample2_fr&quot; &quot;sample3&quot; [89] &quot;sample3_fr&quot; &quot;sd_calc&quot; &quot;sd_calc_ceil&quot; &quot;sd_calc_floor&quot; [93] &quot;sd_calc_round&quot; &quot;sd_time&quot; &quot;sub_only&quot; &quot;sum_aa&quot; [97] &quot;sum_time&quot; &quot;sum_weights&quot; &quot;t_value&quot; &quot;time&quot; [101] &quot;to_extract&quot; &quot;to_print&quot; &quot;total_mito&quot; &quot;total_no_mito&quot; [105] &quot;treatment&quot; &quot;upregulated_1&quot; &quot;upregulated_2&quot; &quot;var_calc&quot; [109] &quot;var1&quot; &quot;var2&quot; &quot;var3&quot; &quot;weight_c&quot; [113] &quot;weight_n&quot; &quot;weight_sup_threshold&quot; # change the value of one variable mice4 &lt;- 7.7 print(mice4) [1] 7.7 Alright, if you have done all the exercises (and I’m sure you have), we can move on to the next chapter in which we briefly talk about scripts and saving the environment. "],["scripts.html", "4 Scripts Save Source a script", " 4 Scripts Ok, let’s take a break before all the theoretical chapters to discuss about scripts. I always say this word when talking to you about my job, but what are they? A script is essentially an ordered list of commands, used to not have to write again and again the same commands on the console. It can contain everything you type in the console, like functions, operations and even comments; in this way, you can do an analysis and store it as a “text” file that you can use as reference (so you know what you have done), use for another analysis, edit, share with others… You will always write code in scripts, for all these reasons. Let’s see how to create a script, write some code in it and run part of the script or even a small part of it in RStudio. In the video we see a series of actions: To create a script, click the button on top left, then select “R Script” (or File -&gt; New File -&gt; R Script) Start writing the commands (even comments) To run a single line click “Run” To run the whole script (R starts from the beginning) click “Source”) Suggetion: Comment, comment, comment everything. I know it is time consuming, but you will be so happy and greatful to read comments that help you understand what you’ve done months (or weeks) before. Save To save a script “File -&gt; Save” or the usual shortcut “Ctrl-S” (Windows) or “Cmd-S” (MacOS). Use them for all the exercise from now on! Source a script Source a script from the console instead of having to open it and source from RStudio is very useful when you want to save time and create re-usable pipelines or analysis. Sourcing a script means to execute all the line of codes in that script. It can be archieved by doing source(\"path_to_file\"). Now, head to the next chapter in which we will talk about numbers. "],["numbers.html", "5 Numbers Operations Rounding Tranform to type number Exercises", " 5 Numbers I know you know what numbers are, and we’ve already seen that we have two types of numbers in R: integers and doubles; so, let’s move to see them in action. Operations First of all, here is how to do basic mathematical operation in R: # Plus, minus, multiply, divide 5 + 4 - 2 * 3 / 2 [1] 6 # Power 4 ** 3 [1] 64 # Logarithm log(100) # base e [1] 4.60517 log10(100) # base 10 [1] 2 log2(100) # base 2 [1] 6.643856 log(100, base = 3) # choose the base [1] 4.191807 # Natural exponential exp(2) [1] 7.389056 # Square root sqrt(9) [1] 3 An interesting operator is the modulus (%%) which returns the remainder of a division, for example: 7 %% 3 [1] 1 This can be useful to evaluate if a number is even or odd by calculating the remainder of the division x / 2 (so using x %% 2): if it is 0, the number x is even, otherwise it is odd. 11 %% 2 [1] 1 12 %% 2 [1] 0 Rounding Another thing that we usually want to do is to round decimal number, especially after log transformation or division. To do so, we have 3 functions: # Round to n decimal places round(x = 1/3, digits = 2) [1] 0.33 # Round to upper integer ceiling(10.2) [1] 11 # Round to lower integer floor(14.9) [1] 14 Look how ceiling and floor do not take into account the decimal part, even if it is greater or lower than 0.5. Tranform to type number Sometimes you want to transform a string that contains a number to a numeric type in R. I know we haven’t covered strings yet (next chapter will be on them), but let’s do a bit step forward now just to see this super useful function, that we use a lot when dealing with dataframes. To do so, we’ll use the function called as.numeric() mystring &lt;- &quot;15&quot; # This is a character, can you guess why R interpret it as a character? typeof(mystring) [1] &quot;character&quot; mynumber &lt;- as.numeric(mystring) typeof(mynumber) [1] &quot;double&quot; Wow, you will find this super super super useful. Exercises Let’s now put in practice what we have seen in this chapter and in the previous (remember? the script… I want you to write a script with these exercises and save it) Exercise 5.1 The results of a Real-Time PCR indicate that your triplicates for FOXP1 have these Ct: 22.4, 22.31, 22.24. Calculate the mean value and print it rounded to 2 decimal places. Solution # calculator solution mean_result_calc &lt;- (22.4 + 22.31 + 22.24) / 3 mean_result_calc &lt;- round(mean_result_calc, digits = 2) print(mean_result_calc) [1] 22.32 # BETTER solution rep1 &lt;- 22.4 rep2 &lt;- 22.31 rep3 &lt;- 22.24 n_rep &lt;- 3 mean_res_better &lt;- (rep1 + rep2 + rep3) / n_rep mean_res_better_round &lt;- round(mean_res_better, digits = 2) print(mean_res_better_round) [1] 22.32 The second solution is better because every number is stored in a variable, that you then use to calculate the mean value. Exercise 5.2 Now calculate the sd of the data of exercise 5.1 and print the value rounded to upper integer, to lower integer and to a 4-digit decimal. Solution # Use only better solution, first calculate the variance var_calc &lt;- ((rep1 - mean_res_better)^2 + (rep2 - mean_res_better)^2 + (rep3 - mean_res_better)^2) / (n_rep - 1) # Now let&#39;s calculate sd sd_calc &lt;- sqrt(var_calc) sd_calc_ceil &lt;- ceiling(sd_calc) print(sd_calc_ceil) [1] 1 sd_calc_floor &lt;- floor(sd_calc) print(sd_calc_floor) [1] 0 sd_calc_round &lt;- round(sd_calc, digits = 4) print(sd_calc_round) [1] 0.0802 Ok, now you’re ready to learn about strings, let’s go. "],["character.html", "6 Character Concatenate strings Substring Substitution Grep Transform to type character Exercises", " 6 Character When you analyze a dataset, you don’t have only numbers: you’ll have gene names, protein names, mouse strains and other variables that R calls character (I will alsways call them strings, but remember that for R they are character). A character can be a single letter, a word or even a whole text. To create a character variable you have to include it in \"\" (double quotes) or in ''(single quotes): mychar_d &lt;- &quot;SEC24C&quot; typeof(mychar_d) [1] &quot;character&quot; mychar_s &lt;- &#39;SEC24C&#39; typeof(mychar_s) [1] &quot;character&quot; Even numbers can be considered as character if included by ““: weight_n &lt;- 12 typeof(weight_n) [1] &quot;double&quot; weight_c &lt;- &quot;12&quot; typeof(weight_c) [1] &quot;character&quot; See? Just adding the double/single quotes it changes everything. IMPORTANT: R interprets everything that is between a pair of single/double quotes as character, so if you forget to close a quote, nothing will work. Moreover, you can’t use a single quote to close a character opened with a double quote and vice versa. Concatenate strings Sometimes you want to concatenate different string into one single string, and we can to it with two similar functions: paste() and paste0(). The unique difference among them is that in the former you can decide what character to use to separate what you are concatenating (default is a white space), while the latter do not insert any character. For example, let’s say you have a variable condition and a variable treatment, and you want to concatenate them to create the variable sample; you will do: condition &lt;- &quot;control&quot; treatment &lt;- &quot;vector&quot; sample &lt;- paste(condition, treatment, sep = &quot;.&quot;) # default is &quot; &quot; print(sample) [1] &quot;control.vector&quot; sample0 &lt;- paste0(condition, treatment) print(sample0) [1] &quot;controlvector&quot; You concatenate as many character as you want, just put them all inside that function. Substring I have to tell you about substring, but I never used this function in my life. It is used to slice the character and take only a part of it. The function is called substr(), let’s see how it works: substr(mychar_s, start = 2, stop = 4) [1] &quot;EC2&quot; It needs a start and a stop value, they are both included in the result (in this case, character at position 2, 3 and 4 are sliced). Remember: in R everything starts at 1, so the first element is at position 1. In other languages it starts from 0, but in R it starts from 1. Extra funtcion never used but that can be important if we use substr and we don’t know how long is a character is nchar() nchar(mychar_s) [1] 6 Let’s say we want to take from position 3 until the end, but we don’t know how long is a character, we can do it with: substr(mychar_s, start = 3, stop = nchar(mychar_s)) [1] &quot;C24C&quot; What happened here is that the result of the function nchar(mychar_s) is used as the value to indicate the stop. We will usually use these method in R, especially when we don’t want to use memory to store a value that is used only once (as in this case). Substitution Alright, let’s move to something way more useful for our analysis: the function sub(), and its big brother gsub(). They are used to substitute part of a character with another, the only difference is that the former changes only the first occurrence, while the latter every occurrence. Let’s say we have the sample variable written as \"control_vector_3\" and we want to get rid of the underscores, we will do: sample2 &lt;- &quot;control_variable_2&quot; sub_only &lt;- sub(pattern = &quot;_&quot;, # the part of the string to search to substitute replacement = &quot; &quot;, # what to use to replace it x = sample2) # variable in which to search print(sub_only) [1] &quot;control variable_2&quot; gsub_all &lt;- gsub(pattern = &quot;_&quot;, # the part of the string to search to substitute replacement = &quot; &quot;, # what to use to replace it x = sample2) # variable in which to search print(gsub_all) [1] &quot;control variable 2&quot; This is the basic way of using these functions, but they can be very useful in complex analysis, but we will see them later on. Grep Further parents of substitution, are grep() and its brother grepl(): they are used to check if a particular pattern is present in a character variable. The first one returns the index (we’ll see this concept in few chapters) or the value of the variable that match the pattern, the second one returns a boolean value (TRUE or FALSE) indicatung the presence of the pattern in the variable. Let’s see few example right away: gene_to_test &lt;- &quot;GAPDH&quot; pattern_to_check_1 &lt;- &quot;GA&quot; pattern_to_check_2 &lt;- &quot;PH&quot; grep_1 &lt;- grep(pattern = pattern_to_check_1, x = gene_to_test, value = T) # default is FALSE (returns index) print(grep_1) [1] &quot;GAPDH&quot; grep_2 &lt;- grep(pattern = pattern_to_check_2, x = gene_to_test, value = T) # default is FALSE (returns index) print(grep_2) character(0) grepl_1 &lt;- grepl(pattern = pattern_to_check_1, x = gene_to_test) print(grepl_1) [1] TRUE grepl_2 &lt;- grepl(pattern = pattern_to_check_2, x = gene_to_test) print(grepl_2) [1] FALSE We can see that the grep_2 gives character(0) as result, meaning that it is an empty character variable. You are going to use grep a lot during the analysis, even if you find it not so interesting now, trust me 😉. Transform to type character As for numbers, we can also convert a variable into a string: we use the function as.character(). You will use this function when a column of a dataframe is read as numeric while you want it to be read as character instead. ml_to_add &lt;- 35 typeof(ml_to_add) [1] &quot;double&quot; ml_to_add &lt;- as.character(ml_to_add) typeof(ml_to_add) [1] &quot;character&quot; This is an important lesson: in R variables can be overwritten with other types of data (this can’t be done in other languages such as Java, C++, ecc.). This can be both handy and risky at the same time: handy because we can save memory by overwriting useless variables, risky because we can overwrite a variable without checking if the type is maintained (maybe it is important). Exercises Exercise 5.2 In a list of genes to test, you found a gene called “NRG_1” and one called “SST R”. In the report you have to present you want to print out “Involved genes are NRG1 and SSTR2”. How to do it? Solution gene1 &lt;- &quot;NRG_1&quot; gene2 &lt;- &quot;SST R&quot; # correct gene names gene1 &lt;- gsub(pattern = &quot;_&quot;, replacement = &quot;&quot;, gene1) gene2 &lt;- gsub(pattern = &quot; R&quot;, replacement = &quot; R2&quot;, gene1) # concatenate all the string all_string &lt;- paste(&quot;Involved genes are&quot;, gene1, &quot;and&quot;, gene2) print(all_string) [1] &quot;Involved genes are NRG1 and NRG1&quot; Exercise 5.2 In a variable you have the gene name “HCN1” and in another you have its number of aa (890, as numeric!!!). Print out the string “HCN1 protein is 890 aa long” Solution gene &lt;- &quot;HCN1&quot; aa_num &lt;- 890 # one string solution to_print &lt;- paste(gene, &quot;protein is&quot;, as.character(aa_num), &quot;aa long&quot;) print(to_print) [1] &quot;HCN1 protein is 890 aa long&quot; Don’t worry if you had done it in another way or if it didn’t work. We are here to learn, and these exercises are done to challenge you on things you have seen in different pieces. Head on to the next lesson, in which we are going to talk about booleans. "],["boolean.html", "7 Boolean Boolean as results of comparison Logical operator Exercises", " 7 Boolean We finally arrived to the last data type that needs a deeper explanation: the boolean (or logical). In programming languages, there are a particular type of data (the boolean) representing what we can imagine as true or false, in R they are represented by two values: TRUE (or T) and FALSE (or F). We can see an example here: t_value &lt;- TRUE f_value &lt;- FALSE typeof(t_value) [1] &quot;logical&quot; typeof(f_value) [1] &quot;logical&quot; R calls them logical (as in computer science). They cannot be explained well if not contextualized, so let’s see some basic practical application here, and be patient, in next lessons we will see another examples. Boolean as results of comparison The most used way to get a logical is to evaluate a comparison, such as compare numbers, compare words ecc. Quickly, for numbers: num1 &lt;- 3 num2 &lt;- 4 # greater than num1 &gt; num2 [1] FALSE # greater equal than num1 &gt;= num2 [1] FALSE # less than num1 &lt; num2 [1] TRUE # less equal than num1 &lt;= num2 [1] TRUE # equality num1 == num2 [1] FALSE # not equal to num1 != num2 [1] TRUE IMPORTANT: I hope you notice that we used == to identity comparison. And I hope you get why we didn’t use only =. If you don’t, remember that one equal sign assign a value to a variable, so in this case you would have overwritten num1 with the value of num2. And what about character? They behave in this way: # define some variables ch1 &lt;- &quot;Mapk13&quot; ch2 &lt;- &quot;MAPK13&quot; ch3 &lt;- &quot;Xist&quot; # Greater than ch1 &gt; ch2 [1] FALSE ch3 &gt; ch1 [1] TRUE &lt; and &gt; with character, contrary to popular belief, do not take into account the number of characters of the string, but the comparison is based on alphabetical order, with lowercase letters that come prior uppercase ones (that’s why Mapk13 is not greater than MAPK13 and Xist). For this reason, two characters are equal only if they have the same letter/number/special character, in the same order and in the same case. For example: ch4 &lt;- &quot;Peg3&quot; ch5 &lt;- &quot;Peg3&quot; ch6 &lt;- &quot;peg3&quot; ch4 == ch5 [1] TRUE ch5 == ch6 [1] FALSE Logical operator Up to now, we have seen logical as a result of comparisons, but what if we want to compare or combine comparisons? I know it sounds silly, but here is an example of implementation of this concept. We will have to do with dataframes, vectors, matrix and other stuff, and we will always filter for some conditions: let’s say that we want to extrapolate data that are below 10 but above 5. These are two comparisons: x &lt; 10 and x &gt; 5. Here we combine two logicals, derived from the two comparisons. The main logical operators, the one that will be useful for us, are AND, OR and NOT AND The AND operator works as follows: TRUE and TRUE = TRUE TRUE and FALSE = FALSE FALSE and TRUE = FALSE FALSE and FALSE = TRUE An easy trick to remember is: if they are identical (both FALSE or TRUE), the result is TRUE, otherwise is FALSE. In R, AND operator is the &amp;, some examples: expr &lt;- 50 (expr &lt; 60) &amp; (expr &gt; 40) # TRUE &amp; TRUE [1] TRUE (expr &lt; 60) &amp; (expr &lt; 40) # TRUE &amp; FALSE [1] FALSE OR The OR operator works as follows: TRUE and TRUE = TRUE TRUE and FALSE = TRUE FALSE and TRUE = TRUE FALSE and FALSE = FALSE An easy trick to remember is: if at least one is TRUE, then the result is TRUE, otherwise if are all FALSE, the result is FALSE. In R, AND operator is the |, some examples: expr &lt;- 50 (expr &lt; 60) | (expr &gt; 40) # TRUE | TRUE [1] TRUE (expr &lt; 60)| (expr &lt; 40) # TRUE | FALSE [1] TRUE NOT The not operator is used to negate an expression, we have seen an example before, when we compared to numbers to see if they were not equal (!=). It is used before the expression to evaluate, in this form: expr &lt;- 50 !(expr &lt; 60) | (expr &lt; 40) # NOT TRUE | FALSE [1] FALSE !((expr &lt; 60) &amp; (expr &lt; 40)) # NOT (TRUE &amp; FALSE) [1] TRUE Here we see two important things: The not operator must be put before a parenthesis (if it contains a comparison) or directly before a TRUE or FALSE variable As for mathematical expressions, order and parenthesis matters: parenthesis and then from left to right Exercises Write a R script with the following exercises, they are level pro (I know you can): Exercise 7.1 Write the expression you would use to evaluate the following statement: we want to see if the patient is in his childhood (2-8 years) and one of its weight is less than 45 kg (as threshold variable) or if its mother has diabetes (we know it is true), and if its nationality is not USA. Tip: here we have 8 variables. I know I didn’t give neither the age nor the weight nor the nationality; you can create these variables and give the values you want. This exercise is to practice the writing and logical part. Solution # create patient variables patient_age &lt;- 5 patient_weight &lt;- 66 mother_diabetes &lt;- TRUE patient_state &lt;- &quot;Italy&quot; # set thresholds and values age_inf_threshold &lt;- 2 age_sup_threshold &lt;- 8 weight_sup_threshold &lt;- 45 nationality &lt;- &quot;USA&quot; ((patient_age &gt; age_inf_threshold &amp; patient_age &lt; age_sup_threshold) | (patient_weight &lt; weight_sup_threshold | mother_diabetes)) &amp; (patient_state != nationality) [1] TRUE It is best practice to use more parenthesis to help the readability by both human and R Ok, next chapter will be on vectors, and we will do another big step towards practical applications and exercise, with real biological questions. "],["vectors.html", "8 Vectors Named vectors Indexing One function can be applied to all elements Function specific of vectors Operations between vectors 8.1 Exercise", " 8 Vectors I know that in the previous chapters you were thinking “ok, but I rarely have one data for a variable, I usually have multiple data”, and you are right, so let’s see the first form of data organization in R, the base of all: the vector. A vector is a collection of data of the same type, for example all the weights of a group of people, all the names of your genes of interest, the expression levels of your genes of interest. To create a vector in R is simple, just use the function c() and put inside every data you need: heights &lt;- c(160, 148, 158, 170) genes &lt;- c(&quot;Adcyp1&quot;, &quot;Tle4&quot;, &quot;Psd95&quot;, &quot;Bip&quot;, &quot;Sst&quot;) heights [1] 160 148 158 170 genes [1] &quot;Adcyp1&quot; &quot;Tle4&quot; &quot;Psd95&quot; &quot;Bip&quot; &quot;Sst&quot; I told you that the data inside of a vector must be of the same type, in fact my_info &lt;- c(14, &quot;Most&quot;, 45, 5, TRUE) my_info [1] &quot;14&quot; &quot;Most&quot; &quot;45&quot; &quot;5&quot; &quot;TRUE&quot; Transforms everything into strings because we have a string in it. To confirm it, we can ask R to tell us the type of data we have in a vector by using the function typeof(): typeof(heights) [1] &quot;double&quot; typeof(my_info) [1] &quot;character&quot; Named vectors There is a particular type of vectors called named vectors that come in handy especially when creating graphs: every value in the vector has a “name” associated to it. Imagine like giving a unique name-tag to each value; for example, associate an expression value to each gene. There are 3 ways of creating a named vector, I will show you here from the most fast to the most complex: # 1st method (the best) # create gene and value vector first genes &lt;- c(&quot;Adcyp1&quot;, &quot;Tle4&quot;, &quot;Psd95&quot;, &quot;Bip&quot;, &quot;Sst&quot;) expr_values &lt;- c(12, 200, 40, 1, 129) # assign names to the vector names(expr_values) &lt;- genes expr_values Adcyp1 Tle4 Psd95 Bip Sst 12 200 40 1 129 You can see here that every expression value has its own name. # 2nd method (as good as the first) # create gene and value vector first genes &lt;- c(&quot;Adcyp1&quot;, &quot;Tle4&quot;, &quot;Psd95&quot;, &quot;Bip&quot;, &quot;Sst&quot;) expr_values &lt;- c(12, 200, 40, 1, 129) # create a structure expr_values &lt;- structure(genes, names = expr_values) expr_values 12 200 40 1 129 &quot;Adcyp1&quot; &quot;Tle4&quot; &quot;Psd95&quot; &quot;Bip&quot; &quot;Sst&quot; This is the preferred method when the values are not in a standalone vectors but, for example, are a column of a dataframe. # 3rd method, the worst # directly create the named vector expr_values &lt;- c(&quot;Adcyp1&quot; = 12, &quot;Tle4&quot; = 200, &quot;Psd95&quot; = 40, &quot;Bip&quot; = 1, &quot;Sst&quot; = 129) expr_values Adcyp1 Tle4 Psd95 Bip Sst 12 200 40 1 129 This takes so long to write and it is never used, as you will always have the values and the names as columns of a dataframe or individual vectors already defined or obtained through a function. But, what is the main advantage of using named vectors? The possibility of extracting values of interest, this is called indexing. Indexing Indexing is one of the most used features, if not the used one, to retrieve data from vector, matrix, dataframes, ecc. There are many ways, let’s start with the named vectors and then move on with other strategies. But first, a tip: the key element in indexing is a pair of squared bracket [], in which you specify what to retrieve. So, remember: parenthesis after a function, square brackets to index. Named vectors To extract values from a named vector, we can put inside the square brackets a character (even a character vector or a character variable) with the name of the value we want to extract: # one value expr_values[&quot;Tle4&quot;] Tle4 200 # a vector expr_values[c(&quot;Tle4&quot;, &quot;Psd95&quot;)] Tle4 Psd95 200 40 # a variable to_extract &lt;- &quot;Bip&quot; expr_values[to_extract] Bip 1 8.0.1 Slicing Another method is to specify the position of the values we want to extract. First, there are two things to keep in mind: In R numeration of index starts at 1, so the first element is at position 1, the second 2 ecc (in other programming language it starts at 0) The length of a vector, meaning the number of items it is composed by can be extrapolate using the function length() Having set these concepts, let’s do some examples (I know it can be boring, but these are the fundamentals of data analysis. you really thank me in the future). # get the length of a vector print(length(expr_values)) [1] 5 Now we know that our expression values vector contains 5 elements, we can now start to index it: # get first element expr_values[1] Adcyp1 12 # get first and third element expr_values[c(1, 3)] Adcyp1 Psd95 12 40 # get from element 2 to 4 expr_values[2:4] Tle4 Psd95 Bip 200 40 1 # get from element 3 to the end expr_values[3:length(expr_values)] Psd95 Bip Sst 40 1 129 # get every element but the third expr_values[-3] Adcyp1 Tle4 Bip Sst 12 200 1 129 Ok, now that we have seen some example, we can look at some of them in more details: expr_values[2:4]: we haven’t seen this yes, but the expression &lt;value1&gt;:&lt;value2&gt; creates a vector with numbers from value1 to value2 expr_values[3:length(expr_values)]: since the function length() returns a value, we can use this function directly into the square brackets expr_values[-3]: the minus indicates except 8.0.2 Use logicals We can also use logical and boolean values to index a vector. This is one of the most used way, and you will use it quite a lot. Why? Let’s see it in action. expr_values[c(T, F, F, T, T)] Adcyp1 Bip Sst 12 1 129 What has happened? When indexed with boolean, only the values in which is TRUE (T) are returned, and this is super cool. Do you remember in the previous chapter how we get boolean as results from an expression?! Great, so we can use expressions that returns TRUE or FALSE and use them to index a vector: # retrieve values &lt; 59 expr_values[expr_values &lt; 59] Adcyp1 Psd95 Bip 12 40 1 We can use also a more complicated expression: # retrieve values &lt; 30 or &gt; 150 expr_values[(expr_values &lt; 30) | (expr_values &gt; 150)] Adcyp1 Tle4 Bip 12 200 1 Do you see how useful it could be in an analysis? I’m sure you do, so let’s move on! One function can be applied to all elements We’ve just seen a feature of the vectors: we can apply a function to each element of the vector. Previously we have evaluated if each element of the vector was &lt; 59 (or &lt; 30 or &gt; 150). Now, we will see more examples, starting from numeric vectors. # operations can be performed to each value expr_values * 2 Adcyp1 Tle4 Psd95 Bip Sst 24 400 80 2 258 expr_values / 10 Adcyp1 Tle4 Psd95 Bip Sst 1.2 20.0 4.0 0.1 12.9 # tranform a numeric vector to a character one as.character(expr_values) [1] &quot;12&quot; &quot;200&quot; &quot;40&quot; &quot;1&quot; &quot;129&quot; With character vectors we can do: # calculate number of characters nchar(genes) [1] 6 4 5 3 3 # use grep to see which genes start with letter T grep(pattern = &quot;^T&quot;, x = genes, value = T) # ^ indicates the start of the line, can you guess why we used it? [1] &quot;Tle4&quot; Function specific of vectors Up to now nothing new, we have not seen any new function. But now we will see some new functions specific for vectors, starting, as always, from numbers: Example 8.1 Let’s say we have a mice and we want to test the time spent in a cage, in particular we want to calculate the sum, the mean and the sd of the time spent not in the center of the cage. # create the named vector areas &lt;- c(&quot;center&quot;, &quot;top&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;left&quot;) time &lt;- c(14, 22, 29, 12, 2) names(time) &lt;- areas # extrapolate data not in center not_center &lt;- time[-(names(time) == &quot;center&quot;)] # calculate mean, sum and sd sum_time &lt;- sum(not_center) mean_time &lt;- mean(not_center) sd_time &lt;- sd(not_center) # print results print(paste(&quot;The mice spent&quot;, sum_time, &quot;seconds not in the center of the cage, with a mean of&quot;, mean_time, &quot;seconds in each area and a sd of&quot;, sd_time)) [1] &quot;The mice spent 65 seconds not in the center of the cage, with a mean of 16.25 seconds in each area and a sd of 11.7862914721581&quot; This example implemented lots of things we have seen up to now, and it shows how on numerical vectors we can calculate sum, mean and sd; but these are not the only functions, we have also var (variance), min, max and others. We are going to see them later when needed. 8.0.3 Sorting a vector Another important function is sort() as it gives us the possibility to sort the values of the vectors. sort(expr_values) Bip Adcyp1 Psd95 Sst Tle4 1 12 40 129 200 sort(expr_values, decreasing = T) Tle4 Sst Psd95 Adcyp1 Bip 200 129 40 12 1 By default, it sorts in ascending order, we can change the behavior by setting decreasing = T. Let’s see a couple of trick with sorting: features &lt;- paste0(&quot;gene&quot;, 1:20) features [1] &quot;gene1&quot; &quot;gene2&quot; &quot;gene3&quot; &quot;gene4&quot; &quot;gene5&quot; &quot;gene6&quot; &quot;gene7&quot; &quot;gene8&quot; &quot;gene9&quot; &quot;gene10&quot; [11] &quot;gene11&quot; &quot;gene12&quot; &quot;gene13&quot; &quot;gene14&quot; &quot;gene15&quot; &quot;gene16&quot; &quot;gene17&quot; &quot;gene18&quot; &quot;gene19&quot; &quot;gene20&quot; sort(features) [1] &quot;gene1&quot; &quot;gene10&quot; &quot;gene11&quot; &quot;gene12&quot; &quot;gene13&quot; &quot;gene14&quot; &quot;gene15&quot; &quot;gene16&quot; &quot;gene17&quot; &quot;gene18&quot; [11] &quot;gene19&quot; &quot;gene2&quot; &quot;gene20&quot; &quot;gene3&quot; &quot;gene4&quot; &quot;gene5&quot; &quot;gene6&quot; &quot;gene7&quot; &quot;gene8&quot; &quot;gene9&quot; What can we see here? First of all, a cool method to create a vector of words with increasing numbers (the combination paste and 1:20); then, we see that sorting has put “gene2” after all “gene1X”, because it sorts in alphabetical order. For this reason, it is recommended to use 01, 02, 03 ecc if we know that we have more than 9 elements (this works also for computer file names). ::: {.example #sort-names} Here we want to sort the expression levels based on their names. ::: expr_values[sort(names(expr_values))] Adcyp1 Bip Psd95 Sst Tle4 12 1 40 129 200 Tadaaa, we used sort on the names of expression levels and used the sorted names to index the named vector. 8.0.4 Unique values As the title suggests, there is a function (unique()) that returns tha unique values of a vector. It is useful in different situations, we will use it a lot. The usage is so simple: # create a vector with repeated values my_vector &lt;- c(1:10, 2:4, 3:6) # can you guess the values of this vector without typing it in R? unique(my_vector) [1] 1 2 3 4 5 6 7 8 9 10 8.0.5 Logical vectors sum and mean In the example 8.1 we have seen how to calculate the sum and the mean of numerical vectors, but it can be done also on vectors full of boolean, and it can be very useful. I’ll show you this example: Example 8.2 We have a vector representing the response to a treatment of different patient, the vector is coded by logicals. Here is the vector: c(T, F, T, T, T, F, T, F, F, T, F, F, F, F, F, T, T). Calculate the number and the percentage of responders (2 decimal places). # 1. Create the vector response &lt;- c(T, F, T, T, T, F, T, F, F, T, F, F, F, F, F, T, T) # 2. Calculate the number of responders n_responders &lt;- sum(response) # 3. Calculate the percentage of responders p_responders &lt;- mean(response) * 100 p_responders &lt;- round(p_responders, 2) print(paste(&quot;There are&quot;, n_responders, &quot;responders, corresponding to&quot;, p_responders, &quot;% of total patients.&quot;)) [1] &quot;There are 8 responders, corresponding to 47.06 % of total patients.&quot; What happened here? The trick is that R interprets TRUE as 1 and FALSE as 0. Remember this also for future applications. Operations between vectors Don’t give up, I know this chapter ha been so long, but now we will see the last part: the most important operations we can do between vectors. 8.0.6 Mathematical First of all, mathematical operations: we can do mathematical operations between vectors only if the vectors are the same size, otherwise it will raise an error. This because each operation is performed one element by the corrisponding element of the other vector. Example 8.3 Let’s say we have 3 vectors representing the total amount of aminoacids found in three different samples for 5 proteins. We want to calculate, for each protein, the fraction of aminoacids in each sample. # 1. Define starting vectors proteins &lt;- c(&quot;SEC24C&quot;, &quot;BIP&quot;, &quot;CD4&quot;, &quot;RSPO2&quot;, &quot;LDB2&quot;) sample1 &lt;- c(12, 52, 14, 33, 22) sample2 &lt;- c(5, 69, 26, 45, 3) sample3 &lt;- c(8, 20, 5, 39, 48) names(sample1) &lt;- names(sample2) &lt;- names(sample3) &lt;- proteins # 2. Calculate sum of aa for each protein sum_aa &lt;- sample1 + sample2 + sample3 # 3. Calculate the fraction for each sample sample1_fr &lt;- sample1 / sum_aa * 100 sample2_fr &lt;- sample2 / sum_aa * 100 sample3_fr &lt;- sample3 / sum_aa * 100 # 4. Print the results sample1_fr SEC24C BIP CD4 RSPO2 LDB2 48.00000 36.87943 31.11111 28.20513 30.13699 sample2_fr SEC24C BIP CD4 RSPO2 LDB2 20.000000 48.936170 57.777778 38.461538 4.109589 sample3_fr SEC24C BIP CD4 RSPO2 LDB2 32.00000 14.18440 11.11111 33.33333 65.75342 Ok, I know it seems difficult, but let’s analyze each step: Here the new step is that we can assign the same values to multiple variables by chaining assignment statements Since the vectors have the same size, we can sum them together. IMPORTANT: the operation is performed based on position, NOT names. So if our vectors would have had the names in different order, we should have ordered them 8.0.7 Different and common elements Usually we want to compare two vectors to find distinct and common elements (eg. upregulated genes in two analysis). To do it, we can use two functions: intersect() (which find the common elements between two vectors), and setdiff() (which returns the element in the first vector not present in the second). # 1. Define 2 vectors upregulated_1 &lt;- c(&quot;NCOA1&quot;, &quot;CENPO&quot;, &quot;ASXL2&quot;, &quot;HADHA&quot;, &quot;ADGRF3&quot;) upregulated_2 &lt;- c(&quot;ADGRF3&quot;, &quot;SLC5A6&quot;, &quot;NRBP1&quot;, &quot;NCOA1&quot;, &quot;HADHA&quot;) # 2. Find common genes common &lt;- intersect(upregulated_1, upregulated_2) # 3. Find different genes only_1 &lt;- setdiff(upregulated_1, upregulated_2) only_2 &lt;- setdiff(upregulated_2, upregulated_1) # 4. Print results print(cat(&quot;Common genes are:&quot;, paste(common, collapse = &quot;, &quot;), &quot;\\n&quot;, &quot;Genes specifically upregulated in analysis 1 are:&quot;, paste(only_1, collapse = &quot;, &quot;), &quot;\\n&quot;, &quot;Genes specifically upregulated in analysis 2 are:&quot;, paste(only_2, collapse = &quot;, &quot;), &quot;\\n&quot;) ) Common genes are: NCOA1, HADHA, ADGRF3 Genes specifically upregulated in analysis 1 are: CENPO, ASXL2 Genes specifically upregulated in analysis 2 are: SLC5A6, NRBP1 NULL Here you are. We can add three more notions: cat() is like print, but it accept special characters when pasting a vector, an additional argument collapse = \"&lt;chr&gt;\" can be added. It tells R to collapse all the element of a vector in a single character element and separate them through (“,” for us) \"\\n\" means add a new line, so it tells to print the next sentence in a new line. It is a special character, so it works with cat/li&gt; 8.0.8 %in% A slightly different function (if we can call it this way) is %in%. When comparing two vectors, it returns TRUE or FALSE for each element of the first vector based on the presence of that element in the second vector: upregulated_1 %in% upregulated_2 [1] TRUE FALSE FALSE TRUE TRUE Sometimes it is useful to index a vector based on another vector. We will see some usages. 8.0.9 Match Last but not least, the match() function. It takes two vectors into consideration and returns, for each element of the first vector, the position of that element in the second vector. If an element is not present, it will return NA, we will describe this element in a dedicated chapter. So, how can it be useful? Usually it is done to rearrange and reorder a vector to match another vector. For example, let’s say that two vectors of example 8.3 have names in different order; prior to do all calculation we need to match the names order. # 1. Define starting vectors proteins1 &lt;- c(&quot;SEC24C&quot;, &quot;BIP&quot;, &quot;CD4&quot;, &quot;RSPO2&quot;, &quot;LDB2&quot;) proteins2 &lt;- c(&quot;CD4&quot;, &quot;RSPO2&quot;, &quot;BIP&quot;, &quot;LDB2&quot;, &quot;SEC24C&quot;) sample1 &lt;- c(12, 52, 14, 33, 22) sample2 &lt;- c(5, 69, 26, 45, 3) names(sample1) &lt;- proteins1 names(sample2) &lt;- proteins2 sample1 SEC24C BIP CD4 RSPO2 LDB2 12 52 14 33 22 sample2 CD4 RSPO2 BIP LDB2 SEC24C 5 69 26 45 3 As we can see, the names are in different order, so we want to fix this: idx &lt;- match(names(sample1), names(sample2)) idx [1] 5 3 1 2 4 We can use these indexes to index our sample2. sample2 &lt;- sample2[idx] sample1 SEC24C BIP CD4 RSPO2 LDB2 12 52 14 33 22 sample2 SEC24C BIP CD4 RSPO2 LDB2 3 26 5 69 45 Now they are in the same order, so we can continue the analysis. 8.1 Exercise Great, let’s do some exercises. They wrap up lots of concept we’ve just seen. However, I encourage you to try again every function we have studied so far. It doesn’t matter if you will do them in a different way, as long as the results are identical. In these chapters I want you to understand the steps, not to use the perfect and most efficient code. Exercise 8.1 We have received the data of the expression levels (in reads) of some genes of interest. We are interested in the difference between expression levels of mitochondrial vs non-mitochondrial genes; in particular we want to see how many reads maps to those categories (both counts and percentage). The starting vector is the following: c(“SEC24C” = 52, “MT-ATP8” = 14, “LDB2” = 22, “MT-CO3” = 16, “MT-ND4” = 2, “NTMT1” = 33, “BIP” = 20, “MT-ND5” = 42) PS: Mitochondrial genes starts with MT-. Solution # 1. Create the vector expr_levels &lt;- c(&quot;SEC24C&quot; = 52, &quot;MT-ATP8&quot; = 14, &quot;LDB2&quot; = 22, &quot;MT-CO3&quot; = 16, &quot;MT-ND4&quot; = 2, &quot;NTMT1&quot; = 33, &quot;BIP&quot; = 20, &quot;MT-ND5&quot; = 42) # 2. Get names of mitochondrial genes mito_genes &lt;- grep(pattern = &quot;^MT-&quot;, x = names(expr_levels), value = T) # 3. Calculate total number of counts for each category total_mito &lt;- sum(expr_levels[mito_genes]) total_no_mito &lt;- sum(expr_levels[-(names(expr_levels) %in% (mito_genes))]) # 4. Calculate % perc_mito &lt;- round(total_mito / sum(expr_levels) * 100, 2) perc_no_mito &lt;- round(total_no_mito / sum(expr_levels) * 100, 2) # 5. Print results cat(&quot;Reads mapping to mitochondrial genes are&quot;, total_mito, &quot;(&quot;, perc_mito, &quot;%), while the ones mapping to other genes are&quot;, total_no_mito, &quot;(&quot;, perc_no_mito, &quot;%)&quot;) Reads mapping to mitochondrial genes are 74 ( 36.82 %), while the ones mapping to other genes are 149 ( 74.13 %) Exercise 8.2 You were given the mass spectrometry results of an analysis on 3 patients. These are the results: patient1 c(“SEC24C” = 12, “CDH7” = 1, “LDB2” = 13, “SEM3A” = 16, “FEZF2” = 21, “NTMT1” = 43, “BIP” = 29, “HOMER” = 22), patient2 c(“SEC24C” = 2, “CDH7” = 11, “SEM5A” = 13, “HCN1” = 22, “NTMT1” = 31, “BIP” = 12, “HOMER” = 8), patient3 c(“SEC24B” = 20, “BIP” = 12, “HOMER” = 13, “SEM3A” = 49, “HCN1” = 16, “NTMT1” = 27). Calculate the expression mean of common genes. Solution # 1. Create the vectors patient1 &lt;- c(&quot;SEC24C&quot; = 12, &quot;CDH7&quot; = 1, &quot;LDB2&quot; = 13, &quot;SEM3A&quot; = 16, &quot;FEZF2&quot; = 21, &quot;NTMT1&quot; = 43, &quot;BIP&quot; = 29, &quot;HOMER&quot; = 22) patient2 &lt;- c(&quot;SEC24C&quot; = 2, &quot;CDH7&quot; = 11, &quot;SEM5A&quot; = 13, &quot;HCN1&quot; = 22, &quot;NTMT1&quot; = 31, &quot;BIP&quot; = 12, &quot;HOMER&quot; = 8) patient3 &lt;- c(&quot;SEC24B&quot; = 20, &quot;BIP&quot; = 12, &quot;HOMER&quot; = 13, &quot;SEM3A&quot; = 49, &quot;HCN1&quot; = 16, &quot;NTMT1&quot; = 27) # 2. Identify common genes common1_2 &lt;- intersect(names(patient1), names(patient2)) common_all &lt;- intersect(common1_2, names(patient3)) # 3. Subset for common genes patien1_sub &lt;- patient1[common_all] patien2_sub &lt;- patient2[common_all] patien3_sub &lt;- patient3[common_all] # 4. Calculate the mean for each gene common_mean &lt;- (patien1_sub + patien2_sub + patien3_sub) / 3 common_mean NTMT1 BIP HOMER 33.66667 17.66667 14.33333 You can see how having the info for each patient in a different vector is not as convenient, for this reason for expression data we use matrix. In the next chapter we will talk about them. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
